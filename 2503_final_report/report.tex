\documentclass[12pt,a4paper,twoside]{report}

\usepackage{comment}
\usepackage{listings}
\usepackage{xcolor}
\usepackage[T1]{fontenc}
\usepackage{listingsutf8}

\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{lmodern}
\usepackage{microtype}

\usepackage[a4paper,margin=1in]{geometry}

\usepackage{xcolor}
\usepackage{graphicx}
\usepackage{capt-of}
\usepackage{float}

\usepackage{array}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{tabularx}

\usepackage{fancyhdr}
\usepackage{lastpage}

\usepackage{titlesec}
\titleformat{\chapter}[hang]
  {\normalfont\huge\bfseries}
  {\chaptertitlename\ \thechapter\ --}
  {0.5em}
  {}

\usepackage{setspace}
\onehalfspacing

\usepackage{enumitem}
\setlist[enumerate]{label=(\arabic*)}

\usepackage{csquotes}
\usepackage[style=ieee,backend=bibtex]{biblatex}
\addbibresource{references.bib}

\definecolor{linkblue}{HTML}{145680}
\definecolor{headergray}{gray}{0.35}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=linkblue,
    urlcolor=linkblue,
    citecolor=linkblue,
    pdfnewwindow=true
}

\pagestyle{fancy}
\fancyhf{}

\fancyhead[LE]{\color{headergray}\sffamily\bfseries Studying link-time optimizations in programming language development to facilitate the continuum of static and dynamic modules}
\fancyhead[RO]{\color{headergray}\sffamily\bfseries\nouppercase{\leftmark}}

\fancyfoot[C]{\sffamily\thepage}

\renewcommand{\chaptermark}[1]{\markboth{Chapter \thechapter\ -- #1}{}}

\fancypagestyle{plain}{\pagestyle{fancy}}

\renewcommand{\headrulewidth}{0pt}
\setlength{\headheight}{24pt}
\setlength{\headsep}{32pt}

\setlength{\parskip}{0.6em}
\setlength{\parindent}{0pt}

\begin{document}

\begin{titlepage}
  \setstretch{1.125}
  \centering
  
  {\large\textbf{Studying link-time optimizations in programming language development to facilitate the continuum of static and dynamic modules}\par}
  
  \vspace{1.5cm}
  
  {\bfseries David Callanan\par}
  {\bfseries 21444104\par}
  
  \vspace{1cm}
  
  {Final Year Project -- 2026\par}
  {B.Sc. Single Honours in Computational Thinking\par}
  
  \vfill
  
  \includegraphics[width=0.5\textwidth]{mu_full.png}
  
  \vfill
  
  {Department of Computer Science\par}
  {Maynooth University\par}
  {Maynooth, Co. Kildare\par}
  {Ireland\par}
  
  \vspace{1cm}
  
  {A thesis submitted in partial fulfilment of the requirements for the\par}
  {B.Sc. Single Honours in Computational Thinking.\par}
  
  \vspace{1cm}
  
  {\textbf{Supervisor: Dr. Phil Maguire}\par}
  
\end{titlepage}

\newpage

\tableofcontents

\newpage

\thispagestyle{empty}

\section*{Declaration}
\addcontentsline{toc}{section}{Declaration}

I hereby certify that this material, which I now submit for assessment on the program of study as part of the B.Sc. Computational Thinking qualification, is entirely my own work and has not been taken from the work of others - save and to the extent that such work has been cited and acknowledged within the text of my work.

I hereby acknowledge and accept that this thesis may be distributed to future final year students, as an example of the standard expected of final year projects.

\vspace{2cm}

Signed: \rule{5cm}{0.4pt} \hfill Date: \rule{3cm}{0.4pt}

\vspace{2cm}

\section*{Acknowledgements}
\addcontentsline{toc}{section}{Acknowledgements}

I would like to thank my parents/guardians/siblings/classmate/friends for their \ldots

\newpage

\begin{abstract}

The logic of computer software is primarily expressed using programming languages, but the balance between versatile and efficient programming languages remains a major challenge. Changes to the execution environment of a program can impact performance, or worse, cause incompatibilities that require major refactoring. Developers often maintain multiple branches of a codebase to keep performance to acceptable levels. One particular difference between execution environments is whether individual modules are statically linked at compile-time or dynamically resolved at runtime. In this research project, we propose a prototype programming language called ``Essence C'' that better supports the continuum of static and dynamic modules, by allowing the programmer to write code once that is agnostic to the linking strategy. By taking advantage of LLVM's intermediate representation, it is possible to advance the state-of-the-art of link-time optimizations across module boundaries.

\end{abstract}

\newpage

\chapter{Introduction}

\section{Overview}



\section{Motivation}



\section{Methodology}

Thesis structure, and a resesarch strategy.

To address the objectives of this research, a design-science methodology is employed with a focus on continued interation and evaluation of ``Essence C''. This approach was selected because the project is concerned with the implementation of a novel programming language that advances the flexibility and performance of modules in software development, and thus requires a design and implementation process that is informed by ongoing evaluation.

The structure of this thesis is organized to reflect this methodology. Chapter 2 reviews existing literature.

\section{Success Criteria}

Success will be evidenced by the following deliverables:

\begin{enumerate}
	\item A functional prototype compiler that implements the designed module system;
	\item Documentation of the module system and other core language features;
	\item A simple IDE extension that provides syntax highlighting to the programmer;
	\item A body of research into the continuum of static and dynamic modules in software development, with kernel development as a case study;
	\item An implementation of link-time optimization techniques that leverage the designed module system;
	\item An evaluation of the effectiveness of these optimizations through the benchmarking of sample programs;
	\item A monorepo containing extensive git history, demonstrating ongoing development progress;
	\item A final written report detailing the research, design, implementation and evaluation of the project.
\end{enumerate}


\chapter{Technical Background}

\section{Literature Review}

\subsection{Static vs dynamic dispatch}

Methods of class instances (or equivalent constructs) dispatch calls either statically or dynamically. When the exact implementation of a method is known at compile-time, static dispatch is typically used, involving a direct assembly call to the method. Since the method is known at compile-time, the compiler can use an immediate addressing, which is most efficient. In contrast, when the exact implementation of a method is not decided until runtime (or if the compiler cannot prove otherwise), dynamic dispatch is used, which involves an indirect call through a vtable or similar structure.

\subsection{Static vs dynamic linking}

There is much overlap in the literature between dispatch and linking, but linking focuses on larger units of code, often referred to as modules or libraries, as opposed to class instances. This concept exists in C where there is no inbuilt notion of static vs dynamic dispatch.

When the exact source code (implementation) of a module is known at compile-time, static linking is typically used, involving the direct inclusion of the module's code into the final executable. Then, the compiler can use immediate addressing to invoke functions or access data from this module. In contrast, when the exact source code of a module is not decided until runtime, dynamic linking is used which typically requires a Procedure Linkage Table (PLT) and Global Offset Table (GOT).

However, various techniques are already employed to optimize dynamic linking:

\begin{enumerate}
  \item Some architectures use the "relaxation" technique to replace indirection at runtime by modifying the assembly instructions.
  \item  PLT Rewriting provided by compilers.
  \item Bespoke replacement (e.g. linux kernel static\_call).
\end{enumerate} 

However, two primary concerns of interest are still evident:

\begin{enumerate}
  \item There is always some level of pointer indirection that cannot be avoided (nvm);
  \item Various techniques such as inlining become impossible due to this indirection.
\end{enumerate}

Terrible PIMPLE idiom. Headers of headers.

\subsection{Module loading in operating system kernels}

\subsection{Link-time optimizations}

Traditionally, many optimizations were performed at the language level, before the program was compiled to object files. For instance, inlining could not be performed at link-time because there was insufficient information in the object files to reason about the semantics of the program. While dedicated link-time optimizations were introduced, their scope was limited for this reason.

However, LLVM IR sits in between the level of abstraction of source code and object files, and maintains higher-level semantics. By keeping the program in this intermediate representation longer (and treating this as modern object files), recent developments have made link-time optimizations more powerful, allowing for, for instance, inlining across module boundaries.



\subsection{Inlining and IR-level linking}

\section{Technical Material}

\subsection{LLVM intermediatea representation}

\chapter{The Problem}

TODO

\chapter{The Solution}

\section{Individual elements}

\subsection{Modules treated like classes}

\subsection{Additional benefit of inlining: interacting with existing languages without indirection.}

\section{Picking of overall solution}

\section{Design}

\section{Implementation}

\subsection{Tooling and Infrastructure}

\subsubsection{Parser Trace Explorer}

Parsing issues were frequently encountered during the development cycle, and manual debugging became infeasible as complexity increased. Hence, a \textit{Parser Trace Explorer} was developed, consisting of a JSON trace logger in the compiler frontend, and a separate web-app tool for exploring these logs. A simple SolidStart + Tanstack Router tech stack was selected for this tool due to existing familiarity with this stack, and because of the straightforward requirements of the tool.

Since parsers try a vast number of rules and are inherently recursive, the logs quickly exceed $500,000$ lines for small source files. To deal with this, the logs are structured as a tree, and the user of the tool is expected to navigate this tree by selecting the precise rule attempts that the parser is supposed to succeed on, thus hiding irrelevant attempts. A dedicated lexer, in hindsight, would have reduced the exponential growth of the logs, but might not have easily parsed some of the unique language features (such as semicolons acting as both terminators and comments).

\chapter{Evaluation}

TODO

\chapter{Conclusion}

TODO

\subsection{Contribution to state-of-the-art}

- inlining
- built in language constructs to avoid likes of kernel static\_call
- continuum of dispatch, not just static vs dynamic, but by merging the notion of class instances (and fusing classes and modules), if we detect multiple instances we can switch to an even more dynamic dispatch mechanism.
- more efficient inter-language interoperability

\chapter{Parsing Library}

Prior to this project I had already developed a simple parsing library in JavaScript, which allows for:

\begin{enumerate}
	\item Parsing terminal rules using regular expressions.
	\item Forming non-terminal rules by combining other rules in the following ways, sufficient to develop any complex grammar: \begin{enumerate}
	\item ``or'' making rule optional
	\item ``join'' sequencing rules
	\item ``multi'' repeating rules zero or more times
	\item ``opt'' making rule optional
	\end{enumerate}
	\item Map parsed data to custom structures using the ``mapData'' function.
\end{enumerate}




\label{LastPage}
\end{document}
